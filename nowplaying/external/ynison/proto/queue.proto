syntax = "proto3";

package ynison_state;

import "playable.proto";
import "update_version.proto";

import "google/protobuf/wrappers.proto";

option go_package = "a.yandex-team.ru/music/backend/music-ynison/hub/proto/ynisonstate";

option java_package = "com.yandex.media.ynison.service";
option java_multiple_files = true;


// Очередь воспроизведения.
message PlayerQueue {
  // Идентификатор сущности.
  // Например, id альбома/плейлиста/радио и проч.
  //
  // У каждого вида сущности свой формат id. Поэтому был введён `message Queue`, в котором
  // все идентификаторы разложены в более правильную структуру.
  //
  // Старое поле будет заполнять бэкенд для совместимости со старыми клиентами, пока не примем
  // решение отключить старых клиентов (спустя 1-2 месяца после того, как последний "новый" клиент
  // поддержит эту доработку). Т.е. новый клиент должен отправлять и читать только новое поле.
  // После удаления пометить поле reserved (правило protubuf).
  string entity_id = 1 [deprecated = true];

  // Удалить вместе с полем `entity_type`. Причины описаны в комментарии к полю.
  enum EntityType {
    option deprecated = true;

    // Fallback value.
    UNSPECIFIED = 0;

    // Common queue, popular tracks of an artist. Consists of [Playable.PlayableType.TRACK]
    ARTIST = 1;

    // Common queue, tracks from a playlist. Consists of [Playable.PlayableType.TRACK]
    PLAYLIST = 2;

    // Common queue, tracks from an album. Consists of [Playable.PlayableType.TRACK]
    ALBUM = 3;

    // Dynamic radio queue, based on recommendations by station seed. Consists of [Playable.PlayableType.TRACK]
    RADIO = 4;

    // Common queue, random set of tracks. Consists of [Playable.PlayableType.TRACK]
    VARIOUS = 5;

    // Stream of neuro music. Consists of [Playable.PlayableType.INFINITE]
    GENERATIVE = 6;

    // Stream of FM radio. Consists of [Playable.PlayableType.INFINITE]
    FM_RADIO = 7;

    // Dynamic video clips queue, based on recommendations.
    VIDEO_WAVE = 8;

    // Common queue, based on tracks located on a device file system.
    // Consists of [Playable.PlayableType.LOCAL_TRACK]
    LOCAL_TRACKS = 9;
  }

  // Тип сущности.
  //
  // Структура сущностей лучшим образом представляется в иерархичной структуре через oneof, а не
  // в плоской структуре через enum. Поэтому был введён `message Queue`, в котором все сущности
  // разложены в более правильную структуру.
  //
  // Старое поле будет заполнять бэкенд для совместимости со старыми клиентами, пока не примем
  // решение отключить старых клиентов (спустя 1-2 месяца после того, как последний "новый" клиент
  // поддержит эту доработку). Т.е. новый клиент должен отправлять и читать только новое поле.
  // После удаления пометить поле reserved (правило protubuf).
  //
  // `message EntityType` удалить вместе с полем.
  EntityType entity_type = 2 [deprecated = true];

  Queue queue = 12;

  // Структура:
  // Каждому виду очередей соотвествует один из типов [Playable.PlayableType].
  // Каждому плеяблу с типом [Playable.PlayableType.TRACK] соотвествует сущность
  // из таблицы сущностей (См. [Queue.WaveQueue.EntityOptions])
  //
  // Очереди не имеет универсального идентификатора. Вместо этого каждая очередь сама решает,
  // что будет её идентифицировать (См. [Queue.type]).
  message Queue {
    oneof type {
      // Все типы очередей в виде message'ей.
      WaveQueue wave_queue = 1;
      GenerativeQueue generative_queue = 2;
      FmRadioQueue fm_radio_queue = 3;
      VideoWaveQueue video_wave_queue = 4;
      LocalTracksQueue local_tracks_queue = 5;
    }

    // Очередь состоит из [Playable.PlayableType.TRACK].
    // Автоматически продляется в случае, если треки закончились.
    // Поддерживает действия "Скип", "Лайк/Дизлайк", "Играть следующим", "Добавить в очередь",
    // "Удалить", "Переместить", "Повтор трека". В общем, все действия, которые поддерживала
    // COMMON очередь.
    //
    // Может находиться в двух состояниях:
    // 1. Играли только треки фонотечных сущностей (исполнитель, плейлист, альбом), но еще не
    // были запрошены рекомендательные треки.
    // 2. Рекомендательные треки были запрошены.
    //
    // В состоянии "без рекомендательных треков" очередь не имеет единого строкового
    // идентификатора, т.к. состоит из треков разных сущностей. Для различения таких очередей
    // друг от друга следует использовать [PlayerQueue.playable_list] и
    // [WaveQueue.EntityOptions]. Как ранее было в VARIOUS.
    // В состоянии "без рекомендательных треков" значение поля
    // [WaveQueue.EntityOptions.wave_entity_optional] не задано.
    //
    // В состоянии "с рекомендательными треками" у очереди в таблице сущностей, в дополнение к
    // фонотечным записям [WaveQueue.EntityOptions.PhonotekaEntity], появляется единственная и
    // уникальная для всей очереди запись [WaveQueue.EntityOptions.WaveSession], которую можно
    // использовать в качестве идентификатора.
    // В этом состоянии поле [WaveQueue.EntityOptions.wave_entity_optional] заполнено.
    //
    // Очередь состоит из трех частей:
    // 1. Прослушанные треки (в `playable_list`). Есть исторический нюанс, что в `playable_list`
    // в конце, при наличии, лежит один первый рекомендованный трек.
    // 2. Добавленные в очередь, но не прослушанные треки (в `playable_list`)
    // 3. Непрослушанные рекомендованные треки (в `recommended_playable_list`)
    // [0, 1, 2, 3a, 4a, ...a, 5r, 6r, ...r], где
    // a - добавленные в очерередь треки, r - рекомендованные.
    message WaveQueue {

      // Непрослушанные рекомендованные треки.
      //
      // У таких треков следует передавать batch_id (см. [TrackInfo.batch_id]).
      //
      // Список может быть непустым только если
      // заполнено [EntityOptions.wave_entity_optional].
      //
      // Есть нюанс, что в `playable_list` в конце, при наличии, лежит один первый
      // рекомендованный трек. Это историческая логика, которая позволяет отображать
      // обложку следующего трека в плеере. Так что первый трек из `recommended_playable_list`
      // будет дублем последнего трека из `playable_list` (при наличии такого трека).
      //
      // При конвертации deprecated стейта в новый, либо переданном пустом списке, бэкенд
      // должен заполнить `recommended_playable_list` одним или нулём треков по следующему
      // алгоритму:
      // 1. Если последний трек из `playable_list` существует и `current_playable_index`
      // не равен `playable_list.size - 1` (текущий индекс не равен индексу последнего трека),
      // то в `recommended_playable_list` должен быть сложен этот последний трек.
      // 2. В противном случае, `recommended_playable_list` должен оставаться пустым.
      //
      // При конвертации нового стейта в deprecated стейт, дополнительно ничего
      // делать не требуется, т.к. клиенты учитывают нюанс формирования `playable_list`.
      repeated Playable recommended_playable_list = 1;

      // Индекс последнего прослушанного трека в состоянии "с рекомендательными треками".
      // Индекс потенциального рекомендательного трека в состоянии "без рекомендательных
      // треков".
      // Другими словами, крайний трек перед добавленными или рекомендованными треками в
      // состоянии "с рекомендательными треками".
      //
      // Например (в состоянии "с рекомендательными треками"):
      // 1. Есть очередь из треков ["0", "1", "2"], все прослушаны. Текущий трек "2".
      // `live_playable_index` равен 2.
      // 2. Есть очередь из треков ["0", "1", "2"], все прослушаны. Текущий трек "2".
      // Ставим "играть следующим" трек "3a". Очередь теперь ["0", "1", "2", "3a"].
      // `live_playable_index` останется равен 2, т.к. трек "3a" ещё не прослушан.
      // 3. Есть очередь из треков ["0", "1", "2"], все прослушаны. Текущий трек "1".
      // Ставим "играть следующим" трек "3a". Очередь теперь ["0", "1", "3a", "2"].
      // `live_playable_index` будет равен 3, т.к. последний прослушанный трек "2" сдвинулся.
      // 4. Очередь пуста - `live_playable_index` равен -1.
      //
      // Валидным индексом считается:
      // 1. В состоянии "с рекомендательными треками" -
      // `live_playable_index in [current_playable_index, playable_list.size)`
      // 2. В состоянии "без рекомендательных треков" -
      // `live_playable_index == playable_list.size`
      // 3. Значение по умолчанию - 0.
      //
      // При конвертации deprecated стейта в новый, либо при переданном значении поля `0`:
      // 1. В состоянии "с рекомендательными треками" бэкенд должен заполнить поле значением
      // равным `playable_list.size - 2`, но не меньшим, чем `current_playable_index`,
      // т.е. возможно значение `playable_list.size - 1`.
      // 2. В состоянии "без рекомендательных треков" значение поля должно быть равно
      // `playable_list.size`, указывая на несуществующий в этом режиме потенциальный
      // рекомендательный трек, который может появиться на этой позиции при продлении очереди.
      //
      // Значение 0 будет приходить на бэкенд в двух случаях:
      // 1. При отправке стейта клиентом, который знает про `message WaveQueue`, но не знает
      // про `live_playable_index`. Здесь требуется вычисление.
      // 2. При `playable_list.size == 1` в состоянии "с рекомендательными треками". Здесь
      // вычисление не имеет смысла, т.к. результат будет равен переданному значению и
      // значению по умолчанию.
      //
      // У треков из `playable_list` следует, по возможности, передавать `batch_id`
      // (см. [TrackInfo.batch_id]).
      //
      // int32 (вместо uint32) чтобы можно было задать -1, когда `playable_list` пустой.
      int32 live_playable_index = 2;

      // Параметры сущностей для смешанной трековой очереди.
      //
      // Волновая очередь by design становится смешанной и забирает под себя все COMMON очереди,
      // т.к. они по функциональности становятся её подмножеством и держать их отдельно
      // смысл пропадает.
      EntityOptions entity_options = 3;

      message EntityOptions {

        // Если в рамках очереди были запрошены рекомендательные треки, то в этом поле будет
        // содержаться сущность с идентификатором rotor-сессии, который никогда не изменится
        // для данной конкретной очереди.
        // Т.е. однажды запросив рекомендательные треки, у очереди появляется [WaveSession],
        // к которой относятся все рекомендованные треки, которые есть в этой очереди.
        // Рекомендованных треков, которые относились бы сразу к нескольким [WaveSession],
        // в рамках одной очереди быть не может.
        //
        // Если поле WaveSession задано, то очередь будет бесконечно достраиваться из этой
        // rotor-сессии и ни из какой другой. До тех пор пока поле не задано, достраиваться
        // очередь не может.
        WaveSession wave_entity_optional = 1;

        message WaveSession {
          // Идентификатор rotor-сессии.
          string session_id = 1;
        }

        // Таблица контекстов/сущностей очереди. Для оптимизации объёма стейта.
        // Чтобы задать контекст для конкретного playable, нужно внутри playable указать
        // ключ из этой таблицы. Таким образом, повторяющиеся контексты не раздуют стейт.
        //
        // См. [Playable.TrackInfo.track_source_key]
        repeated TrackSourceWithKey track_sources = 2;

        message TrackSourceWithKey {
          // Ключ для доступа к сущности в таблице. Должен быть уникальным в рамках таблицы.
          // Стабильность не требуется, т.е. можно при каждой отправке стейта клиентом
          // генерировать ключи заново. Но в рамках одного стейта должно всё быть
          // консистентно, т.е. плеяблы должны содержать в себе корректные ключи.
          //
          // См. [Playable.TrackInfo.track_source_key]
          uint32 key = 1;

          oneof track_source {
            WaveSource wave_source = 2;
            PhonotekaSource phonoteka_source = 3;
          }
        }

        // Пустой message, чтобы поле [Playable.TrackInfo.track_source_key] было не
        // опциональным. А также на случай возможного расширения, если нужно будет
        // поддержать треки из нескольких сессий в рамках одной очереди.
        //
        // В списке [WaveQueue.track_sources] может быть не более одного [WaveSource].
        //
        // Если [Playable.TrackInfo.track_source_key] указывает на [WaveSource], то
        // это значит, что трек был получен из rotor-сессии [WaveSession].
        message WaveSource {}

        message PhonotekaSource {
          // Идентификатор сущности - источника, к которому трек принадлежал до попадания
          // в очередь [WaveQueue].
          oneof id {
            ArtistId artist_id = 2;
            PlaylistId playlist_id = 3;
            AlbumId album_id = 4;
          }

          // Контекст воспроизведения.
          EntityContext entity_context = 1;
        }

        message ArtistId {
          // Идентификатор исполнителя.
          // Почему строковый - смотри [PhonotekaSource.AlbumId]
          string id = 1;
        }

        message PlaylistId {
          // Идентификатор плейлиста. Строковый, потому что идёт процесс отказа от
          // owner:kind. См. MUSICBACKEND-12592
          string id = 1;
        }

        message AlbumId {
          // Идентификатор альбома. Идентификатор мог бы быть числовым, но по историческим
          // причинам он строковый и на бэкенде, и на клиентах. Раньше строка нужна была
          // для ugc. Можно было бы в будущем рассмотреть переход на числовой идентификатор.
          string id = 1;
        }
      }
    }

    // Поток нейромузыки. Состоит из одного [Playable.PlayableType.INFINITE]
    message GenerativeQueue {
      // Идентификатор потока
      string id = 1;
    }

    // Поток ФМ-радио. Состоит из одного [Playable.PlayableType.INFINITE]
    message FmRadioQueue {
      // Идентификатор потока
      string id = 1;
    }

    // Рекомендательная очередь видео-клипов. Состоит из [Playable.PlayableTypeVIDEO_CLIP]
    message VideoWaveQueue {
      // Идентификатор очереди. Это произвольная строка, не имеющая какой-то строгой
      // структуры или связи с БД на бэкенде. Значение может быть "default", "other",
      // "search:${clipId}", "${albumId}".
      string id = 1;
    }

    // Очередь треков с утройства [Playable.PlayableType.LOCAL_TRACK]. Такую очередь нельзя
    // перенести через Юнисон на другое устройство, но можно отобазить простейший пульт.
    // Локальные треки не могут быть перемешаны с обычными треками [Playable.PlayableType.TRACK].
    message LocalTracksQueue {
      // У локальных треков нет идентификатора
    }
  }

  // Индекс playable в очереди.
  // Используется, например, для плейлиста с одинаковыми треками.
  //
  // Всегда содержит индекс сущности из оригинального списка `playable_list`.
  int32 current_playable_index = 3; // int32 (вместо uint32) чтобы можно было задать -1, когда playable_list пустой

  // Список сущностей в очереди.
  repeated Playable playable_list = 4;

  // Настройки плеера.
  PlayerStateOptions options = 5;

  // Версия последнего изменения.
  UpdateVersion version = 6;

  // Настройки шаффла.
  // При выключенном шаффле не приходят.
  Shuffle shuffle_optional = 7;

  // Дополнительная информация для источника трека, используется для уточнения места откуда этот трек взят
  enum EntityContext {
    // Трек взят напрямую из сущности
    // - плейлист
    // - альбом
    // - популярные треки артиста
    BASED_ON_ENTITY_BY_DEFAULT = 0;

    // Трек взят из раздела "Треки" в коллекции
    // Используется только для неизвестного (unspecified) источника
    USER_TRACKS = 1;

    // Трек взят из раздела "Скачанные треки"
    // Используется только для неизвестного (unspecified) источника
    DOWNLOADED_TRACKS = 2;

    // Трек взят из поиска
    // Используется только для неизвестного (unspecified) источника
    SEARCH = 3;

    // Трек взят из истории прослушивания:
    // - когда источник плейлист
    // - когда источник альбом
    // - когда источник артист
    // - для неизвестного (unspecified) источника с вкладки "Слушали вперемешку"
    MUSIC_HISTORY = 4;

    // Трек взят из истории прослушивания c вкладки "Результаты поиска", используется только для неизвестного (unspecified) источника
    MUSIC_HISTORY_SEARCH = 5;

    // Трек взят с экрана "Знакомое вам" c вкладки "У вас в Коллекции"
    // Используется только для источника артиста
    ARTIST_MY_COLLECTION = 6;

    // Трек взят с экрана "Знакомое вам" c вкладки "Слушали в моей волне"
    // Используется только для источника артиста
    ARTIST_FAMILIAR_FROM_WAVE = 7;
  }

  // Контекст воспроизведения.
  //
  // Контекст применим не ко всем сущностям. Поэтому был введён `message Queue`, в котором
  // контекст применяется только к сущностям из фонотеки.
  //
  // Старое поле будет заполнять бэкенд для совместимости со старыми клиентами, пока не примем
  // решение отключить старых клиентов (спустя 1-2 месяца после того, как последний "новый" клиент
  // поддержит эту доработку). Т.е. новый клиент должен отправлять и читать только новое поле.
  // После удаления пометить поле reserved (правило protubuf).
  EntityContext entity_context = 8 [deprecated = true];

  // Опциональный фром очереди.
  //
  // Используется для настройки фрома, когда его нельзя достать из списка `playable_list`.
  // Такое возможно при старте юнисона на основе единой очереди воспроизведения.
  // Если у пользователя играло радио, в ЕОВ будет пустой `playable_list`,
  // соответственно фрома не будет.
  google.protobuf.StringValue from_optional = 9;

  // Изначальный id+type сущности, которой была проинициализирована очередь
  //
  // Хранение этого поля отдельно теряет смысл с введением поддержки смешанной очереди.
  // Информацию об источнике попадания трека в очередь следует брать
  // из [WaveQueue.EntityOptions.track_sources].
  //
  // Старое поле будет заполнять бэкенд для совместимости со старыми клиентами, пока не примем
  // решение отключить старых клиентов (спустя 1-2 месяца после того, как последний "новый" клиент
  // поддержит эту доработку). Т.е. новый клиент должен отправлять и читать только новое поле.
  // После удаления пометить поле reserved (правило protubuf).
  //
  // `message InitialEntity` удалить вместе с полем.
  InitialEntity initial_entity_optional = 10 [deprecated = true];

  // Удалить вместе с полем `initial_entity_optional`. Причины описаны в комментарии к полю.
  message InitialEntity {
    option deprecated = true;

    string entity_id = 1;

    EntityType entity_type = 2;
  }


  // Дополнительные параметры для очередей
  //
  // Теперь эта информация находится в `message Queue`.
  //
  // Старое поле будет заполнять бэкенд для совместимости со старыми клиентами, пока не примем
  // решение отключить старых клиентов (спустя 1-2 месяца после того, как последний "новый" клиент
  // поддержит эту доработку). Т.е. новый клиент должен отправлять и читать только новое поле.
  // После удаления пометить поле reserved (правило protubuf).
  //
  // `message PlayerQueueOptions` удалить вместе с полем.
  PlayerQueueOptions adding_options_optional = 11 [deprecated = true];

  // Удалить вместе с полем `adding_options_optional`. Причины описаны в комментарии к полю.
  message PlayerQueueOptions {
    option deprecated = true;

    // Заполняемое поле зависит от entity_type текущей очереди
    oneof options {
      RadioOptions radio_options = 1;
    }

    // Для entity_type = RADIO(4)
    // Информация о волновой очереди теперь находится
    // в [WaveQueue.EntityOptions.wave_entity_optional].
    message RadioOptions {
      string session_id = 1;
    }
  }

}


message PlayerStateOptions {
  enum RepeatMode {
    UNSPECIFIED = 0;

    // Без повтора.
    NONE = 1;

    // Повтор одного трека.
    ONE = 2;

    // Повтор всей сущности.
    ALL = 3;
  }
  // Режим повтора.
  RepeatMode repeat_mode = 1;
}


message Shuffle {
  // Зашафленный список индексов сущностей в очереди.
  repeated uint32 playable_indices = 1;
}
